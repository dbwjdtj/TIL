# 커널, 부팅, 명령어, 프로그램

## 커널

- 운영체제의 핵심 기능을 모아 놓은 것

| 핵심 기능             | 설명                                          |
| --------------------- | --------------------------------------------- |
| 프로세스 관리         | CPU 배분, 작업에 필요한 제반 환경 제공        |
| 메모리 관리           | 작업 공간을 배치, 가상 공간 제공              |
| 파일 시스템 관리      | 데이터 저장 및 접근할 수 있는 인터페이스 제공 |
| 입출력 관리           | 필요한 입출력 서비스 제공                     |
| 프로세스 간 통신 관리 | 공동 작업을 위한 통신 환경 제공               |

**\*\_제반: 어떤 것과 관련된 모든 것**

**사용자**

- **GUI Graphical User Interface**
  - 사용자가 창, 아이콘, 메뉴와 같은 그래픽 요소를 사용하여 시스템과 상호작용
  - 키보드 + 마우스 사용 가능
- **CLI Command Line Interface**
  - 글자의 입출력을 통해 사용자와 컴퓨터 간 소통하는 방식
  - 키보드 + 명령어 사용 가능

**프로그램(애플리케이션)**

- **System Call**을 활용한 접근
  - **System Call** : 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스

**하드웨어**

- 드라이버 설치로 접근

### 구조

**단일 구조 운영체제**

- 운영체제의 모든 기능을 커널과 동일한 메모리 공간에 적재를 한 뒤 System Call을 통해서 사용할 수 있다.

![](./img/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0%20%EC%A0%84%EC%97%90/1.png)

**계층 구조 운영체제**

- 비슷한 기능을 수행하는 요소를 **그룹화**하여 계층적으로 구성한다.
- 실제로 프로세스의 요청을 수행할 때 0계층부터 5계층까지 거쳐야 한다.
- 각 계층은 인접한 계층과 상호작용하고 하위 계층만 서비스한다.

![](./img/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0%20%EC%A0%84%EC%97%90/2.png)

**마이크로 커널 구조 운영체제**

- 계층형 구조의 문제로 인해 나타난 구조
- **프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 반드시 커널에 있어야 하는 기능**만 모듈로 남아있는 구조

![](./img/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0%20%EC%A0%84%EC%97%90/3.png)

## 부팅

> **전원 버튼** </br>
> ⬇️ </br>
> BIOS(Basic Input Output System) </br>
> ⦁ CPU가 ROM에 있는 BIOS 데이터를 읽어옴 </br>
> ⬇️ </br>
> POST(Power on self test) </br>
> ⦁ BIOS는 POST를 진행하여 하드웨어(주변장치) 상태 점검 </br>
> ⬇️ </br>
> 부트스트랩(Bootstrap) </br>
> ⦁ POST에 이상이 없으면 BIOS는 부트스트랩을 실행시켜 부팅 정보를 메모리로 읽어옴 </br>
> ⬇️ </br>
> 부트로더(Bootloader): 운영체제(Boot)를 메모리로 읽어오는 역할(loader) </br>
> ⦁ 부트로더는 OS 선택 후 디스크에 OS를 올려서 실행

## 명령어

> ⦁ 입력장치로 컴퓨터에 유입되는 정보: 데이터 </br>
> ⦁ 실행할 동작을 명시하는 문장: 명령어 </br>
> ⦁ 명령어의 모임: 프로그램 </br>

> - 프로그램은 컴파일러 등으로 기계 명령어로 변환해야 컴퓨터가 이해할 수 있음

### 명령어 구조

![](./img/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0%20%EC%A0%84%EC%97%90/4.png)

- **연산 부호 (OP-code)**: 프로세서가 실행할 동작인 연산을 지정
- **피연산자(operand)**: 연산할 데이터 정보의 위치 저장

> **I** + OP-code + 피연산자의 주소

- **직접주소 지정 방법 0**: OP-code + 피연산자가 저장된 곳
- **간접주소 지정 방법 1**: OP-code + 피연산자가 저장된 위치가 적혀있는 곳의 주소

### 명령어 사이클

![](./img/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0%20%EC%A0%84%EC%97%90/5.png)

**명령어 인출**

- **PC → MAR**: PC값 MAR로 전달
- **Memory[MAR] → MBR**: MAR 내용의 명령어 인출 → MBR로 저장
- **PC + 1 → PC**: PC + 1 하기
- **MBR → IR**: MBR 내용 IR로 전달

**피연산자 인출**

- IR 내용 확인: 간접, 직접 확인

**명령어 실행**

- 명령어에 따라 실행

## 프로그램

- **프로그램**: 명령어의 집합체
- **프로세스**: 실행 중인 프로그램
  - 구조: 코드, 데이터, 스택, 힙

**컴파일 과정**

> 코딩 </br>
> ⬇️ </br> > **컴파일** : **전처리기 → 컴파일러 → 어셈블러 → 링커** </br>
> ⬇️ </br>
> 실행
